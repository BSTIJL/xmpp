Erlang/Elixir XMPP library
==========================

[![Build Status](https://travis-ci.org/processone/xmpp.svg?branch=master)](https://travis-ci.org/processone/xmpp) [![Coverage Status](https://coveralls.io/repos/processone/xmpp/badge.svg?branch=master&service=github)](https://coveralls.io/github/processone/xmpp?branch=master) [![Hex version](https://img.shields.io/hexpm/v/xmpp.svg "Hex version")](https://hex.pm/packages/xmpp)

The library provides comprehensive representation
of XMPP elements as well as tools to work with them. Every such element
is represented by an Erlang record. Most of the library's code is auto generated
and thus considered to be bug free and efficient.

The library should be used along with [fast_xml](https://github.com/processone/fast_xml)
library, because it is only able to decode from and encode to structures
generated by that library (that is, `xmlel()` elements).

**Table of Contents**:
1. [Status](#status)
2. [Compiling](#compiling)
3. [Usage](#usage)
   1. [Initialization and header files](#initialization-and-header-files)
   2. [XMPP elements](#xmpp-elements)
   3. [Decoding and encoding](#decoding-and-encoding)
   4. [Stanzas](#stanzas)
      1. [Common fields](#common-fields)
      2. [Constructing stanza responses](#constructing-stanza-responses)
   5. [Error elements](#error-elements)
   6. [Text elements](#text-elements)
   7. [Pretty printer](#pretty-printer)
   8. [Namespaces](#namespaces)
   9. [XMPP addresses](#xmpp-addresses)
 4. [API](#api)
    1. [xmpp module](#xmpp-module)
5. [Supported XMPP elements](#supported-xmpp-elements)

# Status

The library is considered as production ready and has been used in
[ejabberd XMPP server](https://www.process-one.net/en/ejabberd) since version 16.12.

# Compiling

As usual, the following commands are used to obtain and compile the library:
```
$ git clone https://github.com/processone/xmpp.git
$ cd xmpp
$ make
```

# Usage

## Initialization and header files

Before calling any function from the library, `xmpp` application should be
started.

Although there are several header files which a developer might find useful
to look into, they should **not** be included directly in the code. Only
[include/xmpp.hrl](include/xmpp.hrl) file should be included, because
it already includes all needed headers and also defines some useful macros.
So the typical code should look like:
```erlang
%% file: foo.erl
-module(foo).
-include_lib("xmpp/include/xmpp.hrl").
...
start() ->
    application:start(xmpp),
    ...
```

## XMPP elements

All XMPP elements (records) are defined in [include/xmpp_codec.hrl](include/xmpp_codec.hrl)
file. For convenience, every record has the corresponding type spec.
There is also predefined `xmpp_element()` type which is a container for all
defined record types: so sometimes we will refer to an arbitrary XMPP element as
`xmpp_element()` in the rest of this document. These records are generated
automatically by
[XML generator](https://github.com/processone/fast_xml/blob/master/src/fxml_gen.erl)
from specification file
[specs/xmpp_codec.spec](specs/xmpp_codec.spec).
The specification file contains information about XML elements
defined within XMPP related namespace.

> **TODO**: writing specs for new elements will be documented later. For now
> you can learn by example: pick up a spec of any element which is very close
> to the one you want to add a spec for and use it as a pattern

> **WARNING**: you should **not** include `xmpp_codec.hrl` in your erlang code.
> Include `xmpp.hrl` instead. `xmpp_codec.hrl` should be only used to
> consult definitions of existing XMPP elements.

## Decoding and encoding

Once an `xmlel()` element is obtained (either using `fxml_stream:parse_element/1`
function or by any other means), it can be decoded using either [decode/1](#decode1)
or [decode/3](#decode3) functions. The result will be an XMPP element. Note
that decoding might fail if there is no known XMPP element for the provided
`xmlel()` element, or `xmlel()` is invalid, so you should call these functions
inside `try ... catch`. Exceptions returned during decoding can be formatted using
[format_error/1](#format_error1) or [io_format_error/1](#io_format_error1)
functions.

**Example**:
```erlang
handle(#iq{type = get, sub_els = [El]} = IQ) ->
    try xmpp:decode(El) of
        Pkt -> handle_iq_child_element(Pkt)
    catch _:{xmpp_codec, Reason} ->
        Txt = xmpp:format_error(Reason),
	io:format("iq has malformed child element: ~s", [Txt]),
	handle_iq_with_malformed_child_element(IQ)
    end.
```

[encode/1](#encode1) and [encode/2](#encode2) functions can be used for reverse
transformation, i.e. to encode an XMPP element into `xmlel()` element.
Encoding would never fail as long as provided XMPP element is valid.

## Stanzas

Amongst all XMPP elements defined in the library, the most notable ones
are stanzas: `message()`, `presence()` and `iq()` elements. A large part of `xmpp`
module deals with stanzas.

### Common fields

Records of all stanzas have several common fields:
`id`, `type`, `lang`, `from`, `to`, `sub_els` and `meta`. Although it's
acceptable to manipulate with these fields directly (which is useful in
pattern matching, for example), `xmpp` module provides several functions
to work with them:
- `id`: [get_id/1](#get_id1) and [set_id/2](#set_id2) can be used
- `type`: [get_type/1](#get_type1) and [set_type/2](#set_type2) can be used
- `lang`: [get_lang/1](#get_lang1) and [set_lang/2](#set_lang2) can be used
- `from` and `to`: [get_from/1](#get_from1), [get_to/1](#get_to1),
  [set_from/2](#set_from2), [set_to/2](#set_to2) and [set_from_to/3](#set_from_to3)
  can be used
- `sub_els`: [get_els/1](#get_els1) and [set_els/2](#set_els2) can be used;
  additional functions to work with subtags directly are:
  [set_subtag/2](#set_subtag2), [get_subtag/2](#get_subtag2),
  [remove_subtag/2](#remove_subtag2), [has_subtag/2](#has_subtag2) and
  [append_subtags/2](#append_subtags2).
- `meta`: this field is intended for attaching arbitrary Erlang terms to
  stanzas; the field is represented by a `map()` and can be manipulated
  using standard [maps](http://erlang.org/doc/man/maps.html) module, but
  also using the following functions: [get_meta/1](#get_meta1),
  [get_meta/2](#get_meta2), [get_meta/3](#get_meta3), [set_meta/2](#set_meta2),
  [put_meta/3](#put_meta3), [update_meta/3](#update_meta3) and
  [del_meta/2](#del_meta2)

### Constructing stanza responses

For creating `iq()` replies the following functions exist:
[make_iq_result/1](#make_iq_result1) and [make_iq_result/2](#make_iq_result2).

These two functions are `iq()` specific and create `iq()` elements of type
`result` only. To create an error response from an arbitrary stanza
(including `iq()`) [make_error/2](#make_error2) function can be used.

## Error elements

A series of functions is provided by `xmpp` module for constructing
`stanza_error()` or `stream_error()` elements. To construct `stanza_error()`
elements the functions with `err_` prefix can be used, such as
[err_bad_request/0](#err_bad_request0) or
[err_internal_server_error/2](#err_internal_server_error2).
To construct `stream_error()` elements the functions with `serr_` prefix
can be used, such as [serr_not_well_formed/0](#serr_not_well_formed0) or
[serr_invalid_from/2](#serr_invalid_from2).

## Text elements

The text element is represented by `#text{}` record (of `text()` type).
Some record fields, such as `#message.body` or `#presence.status`,
contain a list of text elements (i.e. `[text()]`).
To avoid writting a lot of extracting code the following functions can be used
to manipulate with `text()` elements: [get_text/1](#get_text1),
[get_text/2](#get_text2), [mk_text/1](#mk_text1) and [mk_text/2](#mk_text2).

## Pretty printer

For pretty printing of XMPP elements (for example, for dumping elements in
the log in a more readable form), [pp/1](#pp1) function can be used.

## Namespaces

There are many predefined macros for XMPP specific XML namespaces defined
in [include/ns.hrl](include/ns.hrl) such as `?NS_CLIENT` or `?NS_ROSTER`.

> **WARNING**: you should **not** include `ns.hrl` in your erlang code.
> Include `xmpp.hrl` instead. Consult this file only to obtain a macro
> name for the required namespace.

There is also [get_ns/1](#get_ns1) function which can be used
to obtain a namespace of `xmpp_element()` or from `xmlel()` element.

## XMPP addresses

An XMPP address (aka Jabber ID or JID) can be represented using
two types:
- `jid()`: a JID is represented by a record `#jid{}`.
  This type is used to represent JIDs in XMPP elements.
- `ljid()`: a JID is represented by a tuple `{User, Server, Resource}`
  where `User`, `Server` and `Resource` are stringprepped version of
  a nodepart, namepart and resourcepart of a JID respectively.
  This representation is useful for JIDs comparison and when a JID
  should be used as a key (in a Mnesia database, ETS table, etc.)

Both types and the record are defined in [include/jid.hrl](includ/jid.hrl).

> **WARNING**: you should **not** include `jid.hrl` in your erlang code.
> Include `xmpp.hrl` instead.

Functions for working with JIDs are provided by [jid module](#jid-module).

# API

## xmpp module

The following functions are exported from `xmpp` module:
- [decode/1](#decode1)
- [decode/3](#decode3)
- [encode/1](#encode1)
- [encode/2](#encode2)
- [get_id/1](#get_id1)
- [set_id/2](#set_id2)
- [get_type/1](#get_type1)
- [set_type/2](#set_type2)
- [get_lang/1](#get_lang1)
- [set_lang/2](#set_lang2)
- [get_from/1](#get_from1)
- [set_from/2](#set_from2)
- [get_to/1](#get_to1)
- [set_to/2](#set_to2)
- [set_from_to/3](#set_from_to3)
- [get_els/1](#get_els1)
- [set_els/2](#set_els2)
- [get_subtag/2](#get_subtag2)
- [set_subtag/2](#set_subtag2)
- [remove_subtag/2](#remove_subtag2)
- [has_subtag/2](#has_subtag2)
- [append_subtags/2](#append_subtags2)
- [get_meta/1](#get_meta1)
- [get_meta/2](#get_meta2)
- [get_meta/3](#get_meta3)
- [set_meta/2](#set_meta2)
- [put_meta/3](#put_meta3)
- [update_meta/3](#update_meta3)
- [del_meta/2](#del_meta2)
- [is_stanza/1](#is_stanza1)
- [is_known_tag/1](#is_known_tag1)
- [is_known_tag/2](#is_known_tag2)
- [get_ns/1](#get_ns1)
- [get_name/1](#get_name1)
- [make_iq_result/1](#make_iq_result1)
- [make_iq_result/2](#make_iq_result2)
- [make_error/2](#make_error2)
- [get_error/1](#get_error1)
- [format_error/1](#format_error1)
- [io_format_error/1](#io_format_error1)
- [pp/1](#pp1)
- [get_text/1](#get_text1)
- [get_text/2](#get_text2)
- [mk_text/1](#mk_text1)
- [mk_text/2](#mk_text2)

### decode/1
```erlang
-spec decode(El :: xmlel() | xmpp_element()) -> xmpp_element().
```
Shorthand for `decode(El, ?NS_CLIENT, [])`.

### decode/3
```erlang
-spec decode(El :: xmlel() | xmpp_element(),
             Namespace :: binary(),
	     [Option]) -> Pkt :: xmpp_element().
```
Decodes `xmlel()` element into `xmpp_element()`.

The only available value of `Option` is `ignore_els`:
if this option is set, lazy decoding is performed.
By default, full decoding is applied, i.e. all known sub-elements get
decoded. If `El` doesn't possess an `xmlns` attribute, it is
assumed that it is within namespace `Namespace`.

In the examples below we assume `El` is obtained from the following XML:
```xml
<message>
  <composing xmlns='http://jabber.org/protocol/chatstates'/>
  <foo xmlns='unknown:namespace'/>
</message>
```
thus it is defined as:
```erlang
#xmlel{name = <<"message">>,attrs = [],
       children = [#xmlel{name = <<"composing">>,
                          attrs = [{<<"xmlns">>,
                                    <<"http://jabber.org/protocol/chatstates">>}],
                          children = []},
                   #xmlel{name = <<"foo">>,
                          attrs = [{<<"xmlns">>,<<"unknown:namespace">>}],
                          children = []}]}
```
**Example 1**: lazy decoding
```erlang
> xmpp:decode(El, <<"jabber:client">>, [ignore_els]).
#message{id = <<>>,type = normal,lang = <<>>,
         from = undefined,to = undefined,subject = [],body = [],
         thread = undefined,
         sub_els = [#xmlel{name = <<"composing">>,
                           attrs = [{<<"xmlns">>,
                                     <<"http://jabber.org/protocol/chatstates">>}],
                           children = []},
                    #xmlel{name = <<"foo">>,
                           attrs = [{<<"xmlns">>,<<"unknown:namespace">>}],
                           children = []}],
         meta = #{}}
```
Note that sub-elements (a list in `#message.sub_els` field) remain untouched:
during lazy decoding only top-level element is decoded.

**Example 2**: full decoding
```erlang
> xmpp:decode(El, <<"jabber:client">>, []).          
#message{id = <<>>,type = normal,lang = <<>>,
         from = undefined,to = undefined,subject = [],body = [],
         thread = undefined,
         sub_els = [#chatstate{type = composing}],
         meta = #{}}
```
Note that in this case `<foo/>` element is dropped from `#message.sub_els`
because it doesn't correspond to any `xmpp_element()` record.

The function might **fail** with `{xmpp_codec, Reason}` exception.
The value of `Reason` can be used to format the failure reason
into human readable description using [format_error/1](#format_error1)
or [io_format_error/1](#io_format_error1) functions.

**Example 3**: no namespace is provided and `El` doesn't possess any
```erlang
> xmpp:decode(El, <<>>, []).                                   
** exception error: {xmpp_codec,{missing_tag_xmlns,<<"message">>}}
     in function  xmpp_codec:decode/3 (src/xmpp_codec.erl, line 16)
```
It is safe to apply the function to `xmpp_element()`:

**Example 4**: double decoding
```erlang
> xmpp:decode(xmpp:decode(El, <<"jabber:client">>, [])).                                         
#message{id = <<>>,type = normal,lang = <<>>,
         from = undefined,to = undefined,subject = [],body = [],
         thread = undefined,
         sub_els = [#chatstate{type = composing}],
         meta = #{}}
```

### encode/1
```erlang
-spec encode(Pkt :: xmpp_element() | xmlel()) -> El :: xmlel().
```
Shorthand for `encode(Pkt, <<>>)`.

### encode/2
```erlang
-spec encode(Pkt :: xmpp_element() | xmlel(),
             Namespace :: binary()) -> El :: xmlel().
```
Encodes `xmpp_element()` into `xmlel()`.
`Namespace` is a top-level namespace: it is used to tell the codec whether
to include `xmlns` attribute into resulting `xmlel()` element or not -
if the `Pkt` is within the same `Namespace`, `xmlns` attribute will be
omitted in the result.

**Example 1**: encoding without top-level namespace
```erlang
> xmpp:encode(#message{}, <<>>).
#xmlel{name = <<"message">>,
       attrs = [{<<"xmlns">>,<<"jabber:client">>}],
       children = []}
```
**Example 2**: encoding within 'jabber:client' namespace
```erlang
> xmpp:encode(#message{}, <<"jabber:client">>).
#xmlel{name = <<"message">>,attrs = [],children = []}
```
Note that `xmlns` attribute is omitted in this case
because `message()` stanza is defined within 'jabber:client' namespace.

**Example 3**: encoding within 'urn:xmpp:time' namespace
```erlang
> xmpp:encode(#message{}, <<"urn:xmpp:time">>).
#xmlel{name = <<"message">>,
       attrs = [{<<"xmlns">>,<<"jabber:client">>}],
       children = []}
```
Note that `xmlns` is included in the result because
`message()` stanza is not defined within 'urn:xmpp:time' namespace.

**Example 4**: encoding with sub-elements
```erlang
> xmpp:encode(#message{sub_els = [#chatstate{type = composing}]}).
#xmlel{name = <<"message">>,
       attrs = [{<<"xmlns">>,<<"jabber:client">>}],
       children = [#xmlel{name = <<"composing">>,
                          attrs = [{<<"xmlns">>,
                                    <<"http://jabber.org/protocol/chatstates">>}],
                          children = []}]}
```

It's acceptable to encode XMPP elements whose sub-elements are of
mixed content, i.e. `sub_els` field contains both `xmpp_element()` and `xmlel()`
elements as shown in the following example.

**Example 5**: encoding with mixed sub-elements
```erlang
> xmpp:encode(#message{sub_els = [#chatstate{type = composing},
                                  #xmlel{name = <<"foo">>,
                                         attrs = [{<<"xmlns">>, <<"unknown:namespace">>}]}]}).
#xmlel{name = <<"message">>,
       attrs = [{<<"xmlns">>,<<"jabber:client">>}],
       children = [#xmlel{name = <<"composing">>,
                          attrs = [{<<"xmlns">>,
                                    <<"http://jabber.org/protocol/chatstates">>}],
                          children = []},
                   #xmlel{name = <<"foo">>,
                          attrs = [{<<"xmlns">>,<<"unknown:namespace">>}],
                          children = []}]}
```
It is safe to apply the function to `xmlel()` elements

**Example 6**: double encoding
```erlang
> xmpp:encode(xmpp:encode(#message{})).
#xmlel{name = <<"message">>,
       attrs = [{<<"xmlns">>,<<"jabber:client">>}],
       children = []}
```
> **NOTE**: encoding would never fail as long as the
> provided input is a valid `xmpp_element()` with valid values of its record
> fields. Use [Dialyzer](http://erlang.org/doc/man/dialyzer.html) to validate this.

### get_id/1
```erlang
-spec get_id(stanza() | xmlel()) -> binary().
```
Obtains a value of `id` field of a `stanza()` or a value of `id` attribute
of an `xmlel()` element.

**Example 1**: obtaining `id` of `message()`
```erlang
> xmpp:get_id(#message{id = <<"abcd">>}).
<<"abcd">>
```
**Example 2**: obtaining `id` of `xmlele()`
```erlang
> xmpp:get_id(#xmlel{attrs = [{<<"id">>, <<"abcd">>}]}).
<<"abcd">>
```

### set_id/2
```erlang
-spec set_id(iq(), binary()) -> iq();
	    (message(), binary()) -> message();
	    (presence(), binary()) -> presence().
```
Sets `id` field of a `stanza()`.

**Example 1**: setting `id` field of `iq()`
```erlang
xmpp:set_id(#iq{}, <<"abcd">>).
> #iq{id = <<"abcd">>,type = undefined,lang = <<>>,
    from = undefined,to = undefined,sub_els = [],meta = #{}}
```

### get_type/1
```erlang
-spec get_type(iq()) -> iq_type();
	      (message()) -> message_type();
	      (presence()) -> presence_type();
	      (xmlel()) -> binary().
```
Obtains a value of `type` field of a `stanza()` or a value of `type` attribute
of an `xmlel()` element.

**Example 1**: obtaining `type` of `presence()`
```erlang
> xmpp:get_type(#presence{}).                
available
```
**Example 2**: obtaining `type` of `xmlel()`
```erlang
> xmpp:get_type(#xmlel{attrs = [{<<"type">>, <<"set">>}]}).
<<"set">>
```

### set_type/2
```erlang
-spec set_type(iq(), iq_type()) -> iq();
	      (message(), message_type()) -> message();
	      (presence(), presence_type()) -> presence().
```
Sets `type` field of a `stanza()`.

**Example 1**: setting `type` field of `message()`
```erlang
> xmpp:set_type(#message{}, chat).                         
#message{id = <<>>,type = chat,lang = <<>>,from = undefined,
         to = undefined,subject = [],body = [],thread = undefined,
         sub_els = [],meta = #{}}
```

### get_lang/1
```erlang
-spec get_lang(stanza() | xmlel()) -> binary().
```
Obtains a value of `lang` field of a `stanza()` or a value of
`xml:lang` attribute of an `xmlel()` element.

**Example 1**: obtaining `lang` of `iq()`
```erlang
> xmpp:get_lang(#iq{lang = <<"fr">>}).
<<"fr">>
```
**Example 2**: obtaining `xml:lang` of `xmlel()`
```erlang
> xmpp:get_lang(#xmlel{attrs = [{<<"xml:lang">>, <<"fr">>}]}).
<<"fr">>
```

### set_lang/2
```erlang
-spec set_lang(iq(), binary()) -> iq();
	      (message(), binary()) -> message();
	      (presence(), binary()) -> presence().
```
Sets `lang` field of a `stanza()`.

**Example 1**: setting `lang` field of `presence()`
```erlang
> xmpp:set_lang(#presence{}, <<"fr">>).
#presence{id = <<>>,type = available,lang = <<"fr">>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```

### get_from/1
```erlang
-spec get_from(stanza()) -> undefined | jid().
```
Obtains a value of `from` field of a `stanza()`.

**Example 1**: obtaining `from` of `message()`
```erlang
> xmpp:get_from(#message{from = jid:decode(<<"user@server/resource">>)}).    
#jid{user = <<"user">>,server = <<"server">>,
     resource = <<"resource">>,luser = <<"user">>,
     lserver = <<"server">>,lresource = <<"resource">>}
```
**Example 2**: `from` field is not set
```erlang
> xmpp:get_from(#message{}).
undefined
```

### set_from/2
```erlang
-spec set_from(iq(), jid:jid() | undefined) -> iq();
	      (message(), jid:jid() | undefined) -> message();
	      (presence(), jid:jid() | undefined) -> presence().
```
Sets `from` field of a `stanza()`.

**Example 1**: setting `from` field of `presence()`
```erlang
> xmpp:set_from(#presence{}, jid:decode(<<"user@server/resource">>)).
#presence{id = <<>>,type = available,lang = <<>>,
          from = #jid{user = <<"user">>,server = <<"server">>,
                      resource = <<"resource">>,luser = <<"user">>,
                      lserver = <<"server">>,lresource = <<"resource">>},
          to = undefined,show = undefined,status = [],
          priority = undefined,sub_els = [],meta = #{}}
```
**Example 2**: removing `from` value from `iq()`
```erlang
> xmpp:set_from(#iq{from = jid:decode(<<"user@server/resource">>)}, undefined).
#iq{id = <<>>,type = undefined,lang = <<>>,from = undefined,
    to = undefined,sub_els = [],meta = #{}}
```

### get_to/1
```erlang
-spec get_to(stanza()) -> undefined | jid().
```
Obtains a value of `to` field of a `stanza()`.

**Example 1**: obtaining `to` of `message()`
```erlang
> xmpp:get_to(#message{to = jid:decode(<<"user@server/resource">>)}).    
#jid{user = <<"user">>,server = <<"server">>,
     resource = <<"resource">>,luser = <<"user">>,
     lserver = <<"server">>,lresource = <<"resource">>}
```
**Example 2**: `to` field is not set
```erlang
> xmpp:get_to(#message{}).
undefined
```

### set_to/2
```erlang
-spec set_to(iq(), jid:jid() | undefined) -> iq();
	    (message(), jid:jid() | undefined) -> message();
	    (presence(), jid:jid() | undefined) -> presence().
```
Sets `to` field of a `stanza()`.

**Example 1**: setting `to` field of `presence()`
```erlang
> xmpp:set_to(#presence{}, jid:decode(<<"user@server/resource">>)).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,
          to = #jid{user = <<"user">>,server = <<"server">>,
                    resource = <<"resource">>,luser = <<"user">>,
                    lserver = <<"server">>,lresource = <<"resource">>},
          show = undefined,status = [],priority = undefined,
          sub_els = [],meta = #{}}
```
**Example 2**: removing `to` value from `iq()`
```erlang
> xmpp:set_to(#iq{to = jid:decode(<<"user@server/resource">>)}, undefined).  
#iq{id = <<>>,type = undefined,lang = <<>>,from = undefined,
    to = undefined,sub_els = [],meta = #{}}
```

### set_from_to/3
```erlang
-spec set_from_to(iq(), undefined | jid:jid(), undefined | jid:jid()) -> iq();
		 (message(), undefined | jid:jid(), undefined | jid:jid()) -> message();
		 (presence(), undefined | jid:jid(), undefined | jid:jid()) -> presence().
```
Sets `from` and `to` fields of a `stanza()`.

**Example 1**: setting `from` and `to` fields of `message()`
```erlang
> xmpp:set_from_to(#message{}, jid:decode(<<"user1@server.com">>), jid:decode(<<"user2@server.com">>)).
#message{id = <<>>,type = normal,lang = <<>>,
         from = #jid{user = <<"user1">>,server = <<"server.com">>,
                     resource = <<>>,luser = <<"user1">>,
                     lserver = <<"server.com">>,lresource = <<>>},
         to = #jid{user = <<"user2">>,server = <<"server.com">>,
                   resource = <<>>,luser = <<"user2">>,
                   lserver = <<"server.com">>,lresource = <<>>},
         subject = [],body = [],thread = undefined,sub_els = [],
         meta = #{}}
```

### get_els/1
```erlang
-spec get_els(stanza()) -> [xmpp_element() | xmlel()];
	     (xmlel()) -> [xmlel()].
```
Obtains a value of `sub_els` field of a `stanza()` or
child elements of an `xmlel()` element.

**Example 1**: obtaining `sub_els` of `message()`
```erlang
> xmpp:get_els(#message{sub_els = [#chatstate{type = composing}, #xmlel{name = <<"foo">>}]}).
[#chatstate{type = composing},
 #xmlel{name = <<"foo">>,attrs = [],children = []}]
```
**Example 2**: obtaining child elements of `xmlel()`
```erlang
> xmpp:get_els(#xmlel{children = [#xmlel{name = <<"foo">>}, {xmlcdata, <<"bar">>}]}).
[#xmlel{name = <<"foo">>,attrs = [],children = []}]
```
Note that only `xmlel()` elements are returned and `xmlcdata()` is ignored.

### set_els/2
```erlang
-spec set_els(Stanza :: iq(), [xmpp_element() | xmlel()]) -> iq();
	     (Stanza :: message(), [xmpp_element() | xmlel()]) -> message();
	     (Stanza :: presence(), [xmpp_element() | xmlel()]) -> presence().
```
Sets `sub_els` field of `Stanza`.
Note that the function replaces all existing sub-elements of `Stanza`:
use [append_subtags/2](#append_subtags2) if you only want to add new elements.

**Example 1**: setting `sub_els` field of `iq()`
```erlang
> xmpp:set_els(#iq{type = get}, [#ping{}]).
#iq{id = <<>>,type = get,lang = <<>>,from = undefined,
    to = undefined,
    sub_els = [#ping{}],
    meta = #{}}
```
**Example 2**: removing `sub_els` from `presence()`
```erlang
> xmpp:set_els(#presence{sub_els = [#caps{}]}, []).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```

### get_subtag/2
```erlang
-spec get_subtag(Stanza :: stanza(), Tag :: xmpp_element()) -> xmpp_element() | false.
```
Returns first sub-element of `Stanza` matching `Tag`
(i.e. `xmpp_element()` or `xmlel()` element with the same
tag name and namespace as `Tag`) or `false`
if no such element found or decoding of the matched element
has failed.

**Example 1**: obtaining `delay()` element
```erlang
> IQ.
#iq{id = <<"id">>,type = result,lang = <<>>,
    from = undefined,to = undefined,
    sub_els = [#xmlel{name = <<"query">>,
                      attrs = [{<<"node">>,<<"node">>},
                               {<<"xmlns">>,<<"http://jabber.org/protocol/disco#info">>}],
                      children = [#xmlel{name = <<"feature">>,
                                         attrs = [{<<"var">>,<<"feature">>}],
                                         children = []}]}],
    meta = #{}}
> xmpp:get_subtag(IQ, #disco_info{}).
#disco_info{node = <<"node">>,identities = [],
            features = [<<"feature">>],
            xdata = []}
```
**Example 2**: obtaining non-existing element
```erlang
> xmpp:get_subtag(#presence{}, #caps{}).
false
```

In the example below `jid` attribute is malformed, so
the function will return `false`.

**Example 3**: obtaining malformed element
```erlang
> IQ.
#iq{id = <<>>,type = undefined,lang = <<>>,from = undefined,
    to = undefined,
    sub_els = [#xmlel{name = <<"query">>,
                      attrs = [{<<"xmlns">>,
                                <<"http://jabber.org/protocol/disco#items">>}],
                      children = [#xmlel{name = <<"item">>,
                                         attrs = [{<<"jid">>,<<"@">>},
                                                  {<<"xmlns">>,<<"http://jabber.org/protocol/disco#items">>}],
                                         children = []}]}],
    meta = #{}}
> xmpp:get_subtag(IQ, #disco_items{}).
false
```

It is also possible to use the function to obtain already decoded elements
as show in the following example.

**Example 4**: obtaining already decoded element
```erlang
> xmpp:get_subtag(#iq{sub_els = [#ping{}]}, #ping{}).
#ping{}
```

### set_subtag/2
```erlang
-spec set_subtag(Stanza :: iq(), Tag :: xmpp_element()) -> iq();
		(Stanza :: message(), Tag :: xmpp_element()) -> message();
		(Stanza :: presence(), Tag :: xmpp_element()) -> presence().
```
Inserts `Tag` into sub-elements of `Stanza`.
If `Stanza` already contains an element with the same tag name
and namespace as `Tag`, the first occurence of such element is replaced by `Tag`.
Otherwise `Tag` is appended to the end of the list of
sub-elements. Note that even malformed element will be replaced if
it is matched, because decoding is not applied during matching.

**Example 1**: insertion without replacement
```erlang
> xmpp:set_subtag(#presence{sub_els = [#delay{stamp = now()}]}, #nick{name = <<"nick">>}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#delay{stamp = {1489,605315,130667},
                            from = undefined,desc = <<>>},
                     #nick{name = <<"nick">>}],
          meta = #{}}
```
**Example 2**: insertion with replacement
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"nick">>,
                            attrs = [{<<"xmlns">>,
                                      <<"http://jabber.org/protocol/nick">>}],
                            children = [{xmlcdata,<<"old">>}]}],
          meta = #{}}
> xmpp:set_subtag(Presence, #nick{name = <<"new">>}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#nick{name = <<"new">>}],
          meta = #{}}
```

In the example below existing `<delay/>` tag is replaced even
though it's malformed (`<delay/>` element MUST possess `stamp` attribute).

**Example 3**: replacement of malformed matching element
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"delay">>,
                            attrs = [{<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []}],
          meta = #{}}
> xmpp:set_subtag(Presence, #delay{stamp = now()}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#delay{stamp = {1489,605957,281474},
                            from = undefined,desc = <<>>}],
          meta = #{}}
```

### remove_subtag/2
```erlang
-spec remove_subtag(Stanza :: iq(), Tag :: xmpp_element()) -> iq();
		   (Stanza :: message(), Tag :: xmpp_element()) -> message();
		   (Stanza :: presence(), Tag :: xmpp_element()) -> presence().
```
Removes all sub-elements of `Stanza` matching `Tag` (i.e. `xmpp_element()`
or `xmlel()` elements with the same tag name and namespace as `Tag`).
Note that even malformed elements will be removed
if they are matched, because decoding is not applied during matching.

**Example 1**: removing all matching elements
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"delay">>,
                            attrs = [{<<"stamp">>,<<"2017-03-15T20:04:50.711597Z">>},
                                     {<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []},
                     #xmlel{name = <<"delay">>,
                            attrs = [{<<"stamp">>,<<"2017-03-15T20:04:50.711613Z">>},
                                     {<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []}],
          meta = #{}}
> xmpp:remove_subtag(Presence, #delay{}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```
In the example below `<delay/>` tag is removed even
though it's malformed (`<delay/>` element MUST possess `stamp` attribute).

**Example 2**: removing malformed matching element
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"delay">>,
                            attrs = [{<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []}],
          meta = #{}}
> xmpp:remove_subtag(Presence, #delay{}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```

### has_subtag/2
```erlang
-spec has_subtag(Stanza :: stanza(), Tag :: xmpp_element()) -> boolean().
```
Returns `true` if there exists a sub-element of `Stanza` matching `Tag`
(i.e. an `xmpp_element()` or `xmlel()` element with the same tag name
and namespace as `Tag`). Otherwise returns `false`. Note that `true` is
returned even if matched element is malformed, because decoding is not
applied during matching.

**Example 1**: found matching element
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"delay">>,
                            attrs = [{<<"stamp">>,<<"2017-03-15T20:31:17.911811Z">>},
                                     {<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []}],
          meta = #{}}
> xmpp:has_subtag(Presence, #delay{}).
true
```
**Example 2**: no matching elements found
```erlang
> xmpp:has_subtag(#presence{}, #delay{}).
false
```
In the example below `<delay/>` element is considered as being matched
even though it's malformed (`<delay/>` element MUST possess `stamp` attribute).

**Example 3**: found matching malformed element
```erlang
> Presence.
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#xmlel{name = <<"delay">>,
                            attrs = [{<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []}],
          meta = #{}}
> xmpp:has_subtag(Presence, #delay{}).
true.
```

### append_subtags/2
```erlang
-spec append_subtags(Stanza :: iq(), Els :: [xmpp_element() | xmlel()]) -> iq();
		    (Stanza :: message(), Els :: [xmpp_element() | xmlel()]) -> message();
		    (Stanza :: presence(), Els :: [xmpp_element() | xmlel()]) -> presence().
```
Appends a list of elements `Els` to the end of a list of sub-elements of `Stanza`.

**Example 1**: appending elements
```erlang
> Els.
[#xmlel{name = <<"delay">>,
        attrs = [{<<"stamp">>,<<"2017-03-15T20:39:26.339167Z">>},
                 {<<"xmlns">>,<<"urn:xmpp:delay">>}],
        children = []},
 #stanza_error{type = modify,code = 400,by = <<>>,
               reason = 'bad-request',text = undefined,sub_els = []}]
> xmpp:append_subtags(#presence{sub_els = [#caps{}]}, Els).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,
          sub_els = [#caps{node = <<>>,version = <<>>,hash = <<>>,
                           exts = []},
                     #xmlel{name = <<"delay">>,
                            attrs = [{<<"stamp">>,<<"2017-03-15T20:39:26.339167Z">>},
                                     {<<"xmlns">>,<<"urn:xmpp:delay">>}],
                            children = []},
                     #stanza_error{type = modify,code = 400,by = <<>>,
                                   reason = 'bad-request',text = undefined,sub_els = []}],
          meta = #{}}
```

### get_meta/1
```erlang
-spec get_meta(Stanza :: stanza()) -> Meta :: map().
```
 Returns metadata associated with `Stanza` (that is,
 the value of its `meta` field).

**Example 1**: obtaining metadata
```erlang
> xmpp:get_meta(#presence{meta = #{foo => bar}}).
#{foo => bar}
```

### get_meta/2
```erlang
-spec get_meta(Stanza :: stanza(), Key :: any()) -> Value :: any().
```
Returns value `Value` associated with `Key` if metadata of `Stanza` contains `Key`.
Fails with a `{badkey, Key}` exception otherwise.

**Example 1**: obtaining a value
```erlang
> xmpp:get_meta(#presence{meta = #{foo => bar}}, foo).
bar
```
**Example 2**: key not found
```erlang
> xmpp:get_meta(#presence{meta = #{foo => bar}}, bar).
** exception error: {badkey,bar}
     ...
```

### get_meta/3
```erlang
-spec get_meta(Stanza :: stanza(), Key :: any(), Default :: any()) -> Value :: any().
```
Returns value `Value` associated with `Key` if metadata of `Stanza` contains `Key`.
If no value is associated with `Key`, `Default` is returned.

**Example 1**: obtaining a value
```erlang
> xmpp:get_meta(#presence{meta = #{foo => bar}}, foo, undefined).
bar
```
**Example 2**: key not found
```erlang
> xmpp:get_meta(#presence{meta = #{foo => bar}}, bar, undefined).
undefined
```

### set_meta/2
```erlang
-spec set_meta(Stanza :: stanza(), Meta :: map()) -> stanza().
```
Sets metadata of `Stanza`.

**Example 1**: setting metadata
```erlang
> xmpp:set_meta(#presence{}, #{foo => bar}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],
          meta = #{foo => bar}}
```
**Example 2**: removing entire metadata
```erlang
> xmpp:set_meta(#presence{meta = #{foo => bar}}, #{}).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```

### put_meta/3
```erlang
-spec put_meta(Stanza :: stanza(), Key :: any(), Value :: any()) -> stanza().
```
Associates `Key` with value `Value` and inserts the association into
metadata of `Stanza`.

**Example 1**: sets new key in metadata
```erlang
> xmpp:put_meta(#presence{}, foo, bar).                    
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],
          meta = #{foo => bar}}
```
**Example 2**: replacing existing key in metadata
```erlang
> xmpp:put_meta(#presence{meta = #{foo => bar}}, foo, baz).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],
          meta = #{foo => baz}}
```

### update_meta/3
```erlang
-spec update_meta(Stanza :: stanza(), Key :: any(), Value :: any()) -> Stanza :: stanza().
```
If `Key` exists in metadata of `Stanza`, the old associated value is replaced by value `Value`.
Fails with `{badkey,Key}` exception if no value is associated with `Key`.

**Example 1**: updating existing key
```erlang
> xmpp:update_meta(#presence{meta = #{foo => bar}}, foo, baz).
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],
          meta = #{foo => baz}}
```
**Example 2**: updating non-existing key
```erlang
> xmpp:update_meta(#presence{}, foo, bar).                    
** exception error: {badkey,foo}
     ...
```

### del_meta/2
```erlang
-spec del_meta(Stanza :: stanza(), Key :: any()) -> stanza().
```
Removes the `Key`, if it exists, and its associated value from
metadata of `Stanza`.

**Example 1**: removing value by key
```erlang
> xmpp:del_meta(#presence{meta = #{foo => bar}}, foo).        
#presence{id = <<>>,type = available,lang = <<>>,
          from = undefined,to = undefined,show = undefined,
          status = [],priority = undefined,sub_els = [],meta = #{}}
```

### is_stanza/1
```erlang
-spec is_stanza(Term :: any()) -> boolean().
```
Returns `true` if `Term` is either of type `stanza()` or an `xmlel()`
element representing stanza. Returns `false` otherwise.

**Examples**:
```erlang
> xmpp:is_stanza(#iq{}).
true
> xmpp:is_stanza(#disco_info{}).
false.
> xmpp:is_stanza(123).
false.
> xmpp:is_stanza(#xmlel{name = <<"message">>}).
true
> xmpp:is_stanza(#xmlel{name = <<"foo">>}).
false.
```

### is_known_tag/1
```erlang
-spec is_known_tag(El :: xmlel()) -> boolean().
```
Shorthand for `is_known_tag(El, ?NS_CLIENT)`.

### is_known_tag/2
```erlang
-spec is_known_tag(El :: xmlel(), Namespace :: binary()) -> boolean().
```
Returns `true` if `El` has corresponding `xmpp_element()`.
Otherwise returns `false`.
If `El` doesn't possess an `xmlns` attribute it's assumed
that it is within namespace `Namespace`.

> **NOTE**: if `El` is considered known doesn't mean it's valid:
> decoding may still fail.

**Example 1**: the tag is known
```erlang
> xmpp:is_known_tag(#xmlel{name = <<"x">>, attrs = [{<<"xmlns">>,<<"http://jabber.org/protocol/muc">>}]}).
true
```
**Example 2**: the tag is unknown
```erlang
> xmpp:is_known_tag(#xmlel{name = <<"foo">>, attrs = [{<<"xmlns">>,<<"bar">>}]}).                         
false
```
**Example 3**: the element lacks namespace, so it's always unknown
```erlang
> xmpp:is_known_tag(#xmlel{name = <<"x">>}).                                                              
false
```
**Example 4**: the element lacks namespace, but we assume it's within 'jabber:server' namespace
```erlang
> xmpp:is_known_tag(#xmlel{name = <<"message">>}, <<"jabber:server">>).
true
```

### get_ns/1
```erlang
-spec get_ns(El :: xmpp_element() | xmlel()) -> Namespace :: binary().
```
Returns namespace of `xmpp_element()` or `xmlel()` element.

**Example 1**: obtaining namespace of `xmpp_element()`
```erlang
> xmpp:get_ns(#disco_info{}).                 
<<"http://jabber.org/protocol/disco#info">>
```
**Example 2**: obtaining namespace of `xmlel()` element
```erlang
> xmpp:get_ns(#xmlel{attrs = [{<<"xmlns">>, <<"foo:bar">>}]}).
<<"foo:bar">>
```

### get_name/1
```erlang
-spec get_name(xmpp_element() | xmlel()) -> binary().
```
Returns tag name of `xmpp_element()` or `xmlel()` element.

**Example 1**: obtaining tag name of `xmpp_element()`
```erlang
> xmpp:get_name(#disco_info{}).
<<"query">>
> xmpp:get_name(#chatstate{type = composing}).
<<"composing">>
```
**Example 2**: obtaining tag name of `xmlel()` element
```erlang
> xmpp:get_name(#xmlel{name = <<"some">>}).
<<"some">>
```

### make_iq_result/1
```erlang
-spec make_iq_result(IQ :: iq()) -> iq().
```
Creates from `IQ` an `iq()` of type `result` with empty sub-elements.

**Example 1**: creating a result
```erlang
> xmpp:make_iq_result(#iq{type = get, id = <<"1">>, sub_els = [#ping{}]}).
#iq{id = <<"1">>,type = result,lang = <<>>,from = undefined,
    to = undefined,sub_els = [],meta = #{}}
```
> **WARNING**: only `iq()` of type `set` or `get` should be provided,
> otherwise the function will fail

**Example 2**: trying to create a result of a result
```erlang
> xmpp:make_iq_result(#iq{type = result, id = <<"1">>}).
** exception error: no function clause matching 
```

### make_iq_result/2
```erlang
-spec make_iq_result(IQ :: iq(), El :: xmpp_element() | xmlel()) -> iq().
```
Creates from `IQ` an `iq()` of type `result` with sub-elements set to `[El]`.

**Example 1**: creating a result
```erlang
> xmpp:make_iq_result(#iq{type = get, id = <<"1">>}, #disco_info{features = [<<"feature">>]}).
#iq{id = <<"1">>,type = result,lang = <<>>,from = undefined,
    to = undefined,
    sub_els = [#disco_info{node = <<>>,identities = [],
                           features = [<<"feature">>],
                           xdata = []}],
    meta = #{}}
```

> **WARNING**: only `iq()` of type `set` or `get` should be provided,
> otherwise the function will fail

**Example 2**: trying to create a result of a result
```erlang
> xmpp:make_iq_result(#iq{type = result, id = <<"1">>}, #disco_items{}).
** exception error: no function clause matching 
```

### make_error/2
```erlang
-spec make_error(Stanza :: stanza(), stanza_error() | xmlel()) -> stanza();
                (El :: xmlel(), stanza_error() | xmlel()) -> xmlel().
```
Constructs `stanza()` of type `error` from `Stanza`.

> **WARNING**: `Stanza` should not have type `error` or `result`,
> otherwise the function will fail

**Example 1**: creating message-error
```erlang
> xmpp:make_error(#message{type = chat}, xmpp:err_bad_request()).
#message{id = <<>>,type = error,lang = <<>>,
         from = undefined,to = undefined,subject = [],body = [],
         thread = undefined,
         sub_els = [#stanza_error{type = modify,code = 400,by = <<>>,
                                  reason = 'bad-request',text = undefined,sub_els = []}],
         meta = #{}}
```
**Example 2**: trying to create an error from an error
```erlang
> xmpp:make_error(#presence{type = error}, xmpp:err_bad_request()).
** exception error: no function clause matching 
```

### get_error/1
```erlang
-spec get_error(Stanza :: stanza()) -> undefined | stanza_error().
```
Returns `stanza_error()` sub-element from `Stanza` or `undefined`
if not found.

**Example 1**: extracting `stanza_error()` element
```erlang
> Err.
#xmlel{name = <<"error">>,
       attrs = [{<<"code">>,<<"400">>},{<<"type">>,<<"modify">>}],
       children = [#xmlel{name = <<"bad-request">>,
                          attrs = [{<<"xmlns">>,
                                    <<"urn:ietf:params:xml:ns:xmpp-stanzas">>}],
                          children = []}]}
> xmpp:get_error(#message{sub_els = [Err]}).
#stanza_error{type = modify,code = 400,by = <<>>,
              reason = 'bad-request',text = undefined,sub_els = []}
```
**Example 2**: no `stanza_error()` element found
```erlang
> xmpp:get_error(#message{}).                                  
undefined
```

### format_error/1
```erlang
-spec format_error(_) -> binary().
```
Creates diagnostic text from an error generated by [decode/1](#decode1)
or [decode/3](#decode3).

**Examples**:
```erlang
> try xmpp:decode(#xmlel{name = <<"foo">>})
  catch _:{xmpp_codec, Reason} -> xmpp:format_error(Reason)
  end. 
<<"Unknown tag <foo/> qualified by namespace 'jabber:client'">>
> try xmpp:decode(#xmlel{name = <<"iq">>})
  catch _:{xmpp_codec, Reason} -> xmpp:format_error(Reason)
  end.
<<"Missing attribute 'id' in tag <iq/> qualified by namespace 'jabber:client'">>
> try xmpp:decode(#xmlel{name = <<"x">>}, <<>>, [])
  catch _:{xmpp_codec, Reason} -> xmpp:format_error(Reason)
  end.
<<"Missing namespace for tag <x/>">>
```

### io_format_error/1
```erlang
-spec io_format_error(_) -> {binary(), [binary()]}.
```
Same as [format_error/1](#format_error1), but result is
suitable for using in formatting functions from
[io](http://erlang.org/doc/man/io.html) or
[io_lib](http://erlang.org/doc/man/io_lib.html) modules.

**Example**:
```erlang
> {Format, Args} = try xmpp:decode(#xmlel{name = <<"iq">>})
                   catch _:{xmpp_codec, Reason} -> xmpp:io_format_error(Reason)
		   end.
{<<"Missing attribute '~s' in tag <~s/> qualified by namespace '~s'">>,
 [<<"id">>,<<"iq">>,<<"jabber:client">>]}
> io:format(Format, Args).
Missing attribute 'id' in tag <iq/> qualified by namespace 'jabber:client'
```

### pp/1
```erlang
-spec pp(any()) -> iodata().
```
Pretty printer for XMPP elements.

**Example**:
```erlang
> S = xmpp:pp(#sm_a{h = 10, xmlns = <<"urn:xmpp:sm:3">>}).  
["#sm_a",123,
 [["h"," = ",49,48],
  44,
  ["xmlns"," = ",60,60,"\"urn:xmpp:sm:3\"",62,62]],
 125]
> io:format(S).
#sm_a{h = 10,xmlns = <<"urn:xmpp:sm:3">>}
```

### get_text/1
```erlang
-spec get_text(Text :: [text()]) -> binary().
```
Shorthand for `get_text(Text, <<"en">>)`.

### get_text/2
```erlang
-spec get_text(Text :: [text()], Lang :: binary()) -> binary().
```
Extracts data from a list of `text()` elements, tagged by language `Lang`.

**Example**:
```erlang
> Text.
[#text{lang = <<"en">>,data = <<"hello">>},
 #text{lang = <<"ru">>,data = <<"привет">>}]
> xmpp:get_text(Text, <<"ru">>).
<<"привет">>
> xmpp:get_text(Text, <<"en">>).
<<"hello">>
> xmpp:get_text(Text, <<"fr">>).
<<"hello">>
```

### mk_text/1
```erlang
-spec mk_text(Text :: binary() | {io:format(), list()}) -> [text()].
```
Shorthand for `mk_text(Text, <<"en">>)`.

### mk_text/2
```erlang
-spec mk_text(binary() | {io:format(), list()}, Lang :: binary()) -> [text()].
```
Creates a list of a single `text()` element from `binary()` or formatted text,
translated into language `Lang` using `translate:translate/2`.

> **TODO**: currently doesn't work outside ejabberd

**Example**:
```erlang
> xmpp:mk_text(<<"hello">>, <<"en">>).
[#text{lang = <<"en">>, data = <<"hello">>}]
> xmpp:mk_text({"hello, ~s!", ["Bob"]}, <<"en">>).
[#text{lang = <<"en">>, data = <<"hello, Bob!">>}]
```

# Supported XMPP elements

XMPP elements from the following documents are supported:
- [RFC 6120](https://tools.ietf.org/html/rfc6120): XMPP Core
- [RFC 6121](https://tools.ietf.org/html/rfc6121): XMPP Instant Messaging and Presence
- [XEP-0004](https://xmpp.org/extensions/xep-0004.html):  Data Forms
- [XEP-0012](https://xmpp.org/extensions/xep-0012.html):  Last Activity
- [XEP-0013](https://xmpp.org/extensions/xep-0013.html):  Flexible Offline Message Retrieval
- [XEP-0016](https://xmpp.org/extensions/xep-0016.html):  Privacy Lists
- [XEP-0022](https://xmpp.org/extensions/xep-0022.html):  Message Events
- [XEP-0023](https://xmpp.org/extensions/xep-0023.html):  Message Expiration
- [XEP-0030](https://xmpp.org/extensions/xep-0030.html):  Service Discovery
- [XEP-0033](https://xmpp.org/extensions/xep-0033.html):  Extended Stanza Addressing
- [XEP-0039](https://xmpp.org/extensions/xep-0039.html):  Statistics Gathering
- [XEP-0045](https://xmpp.org/extensions/xep-0045.html):  Multi-User Chat
- [XEP-0048](https://xmpp.org/extensions/xep-0048.html):  Bookmarks
- [XEP-0049](https://xmpp.org/extensions/xep-0049.html):  Private XML Storage
- [XEP-0050](https://xmpp.org/extensions/xep-0050.html):  Ad-Hoc Commands
- [XEP-0054](https://xmpp.org/extensions/xep-0054.html):  vcard-temp
- [XEP-0055](https://xmpp.org/extensions/xep-0055.html):  Jabber Search
- [XEP-0059](https://xmpp.org/extensions/xep-0059.html):  Result Set Management
- [XEP-0060](https://xmpp.org/extensions/xep-0060.html):  Publish-Subscribe
- [XEP-0065](https://xmpp.org/extensions/xep-0065.html):  SOCKS5 Bytestreams
- [XEP-0066](https://xmpp.org/extensions/xep-0066.html):  Out of Band Data
- [XEP-0077](https://xmpp.org/extensions/xep-0077.html):  In-Band Registration
- [XEP-0078](https://xmpp.org/extensions/xep-0078.html):  Non-SASL Authentication
- [XEP-0085](https://xmpp.org/extensions/xep-0085.html):  Chat State Notifications
- [XEP-0092](https://xmpp.org/extensions/xep-0092.html):  Software Version
- [XEP-0114](https://xmpp.org/extensions/xep-0114.html):  Jabber Component Protocol
- [XEP-0115](https://xmpp.org/extensions/xep-0115.html):  Entity Capabilities
- [XEP-0131](https://xmpp.org/extensions/xep-0131.html):  Stanza Headers and Internet Metadata
- [XEP-0138](https://xmpp.org/extensions/xep-0138.html):  Stream Compression
- [XEP-0153](https://xmpp.org/extensions/xep-0153.html):  vCard-Based Avatars
- [XEP-0158](https://xmpp.org/extensions/xep-0158.html):  CAPTCHA Forms
- [XEP-0172](https://xmpp.org/extensions/xep-0172.html):  User Nickname
- [XEP-0191](https://xmpp.org/extensions/xep-0191.html):  Blocking Command
- [XEP-0198](https://xmpp.org/extensions/xep-0198.html):  Stream Management
- [XEP-0199](https://xmpp.org/extensions/xep-0199.html):  XMPP Ping
- [XEP-0202](https://xmpp.org/extensions/xep-0202.html):  Entity Time
- [XEP-0203](https://xmpp.org/extensions/xep-0203.html):  Delayed Delivery
- [XEP-0220](https://xmpp.org/extensions/xep-0220.html):  Server Dialback
- [XEP-0221](https://xmpp.org/extensions/xep-0221.html):  Data Forms Media Element
- [XEP-0231](https://xmpp.org/extensions/xep-0231.html):  Bits of Binary
- [XEP-0249](https://xmpp.org/extensions/xep-0249.html):  Direct MUC Invitations
- [XEP-0264](https://xmpp.org/extensions/xep-0264.html):  Jingle Content Thumbnails
- [XEP-0279](https://xmpp.org/extensions/xep-0279.html):  Server IP Check
- [XEP-0280](https://xmpp.org/extensions/xep-0280.html):  Message Carbons
- [XEP-0297](https://xmpp.org/extensions/xep-0297.html):  Stanza Forwarding
- [XEP-0313](https://xmpp.org/extensions/xep-0313.html):  Message Archive Management
- [XEP-0334](https://xmpp.org/extensions/xep-0334.html):  Message Processing Hints
- [XEP-0352](https://xmpp.org/extensions/xep-0352.html):  Client State Indication
- [XEP-0355](https://xmpp.org/extensions/xep-0355.html):  Namespace Delegation
- [XEP-0356](https://xmpp.org/extensions/xep-0356.html):  Privileged Entity
- [XEP-0359](https://xmpp.org/extensions/xep-0359.html):  Unique and Stable Stanza IDs
- [XEP-0363](https://xmpp.org/extensions/xep-0363.html):  HTTP File Upload
- [XEP-0369](https://xmpp.org/extensions/xep-0369.html):  Mediated Information eXchange (MIX)
- [draft-cridland-xmpp-session-01](https://tools.ietf.org/html/draft-cridland-xmpp-session-01): XMPP Session Establishment

As well as some proprietary extensions from [ProcessOne](https://www.process-one.net)
